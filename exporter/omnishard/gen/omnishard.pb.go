// Code generated by protoc-gen-go. DO NOT EDIT.
// source: omnishard.proto

/*
Package omnishard is a generated protocol buffer package.

It is generated from these files:
	omnishard.proto

It has these top-level messages:
	ExportRequest
	EncodedRecord
	ExportResponse
	ShardDefinition
	ShardingConfig
	ConfigRequest
*/
package omnishard

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ExportResponse_ResultCode int32

const (
	// Successfully received and accepted.
	ExportResponse_SUCCESS ExportResponse_ResultCode = 0
	// Failed to process the data. Sender MUST NOT retry this request.
	ExportResponse_FAILED_NOT_RETRYABLE ExportResponse_ResultCode = 1
	// Failed to process the data. Sender SHOULD retry this request.
	ExportResponse_FAILED_RETRYABLE ExportResponse_ResultCode = 2
	// Sharding configuration at receiver does not match
	// sharding performed by sender. Sender MUST re-shard the
	// data according to new sharding configuration specified
	// in shardingConfig field and send again.
	ExportResponse_SHARD_CONFIG_MISTMATCH ExportResponse_ResultCode = 3
)

var ExportResponse_ResultCode_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILED_NOT_RETRYABLE",
	2: "FAILED_RETRYABLE",
	3: "SHARD_CONFIG_MISTMATCH",
}
var ExportResponse_ResultCode_value = map[string]int32{
	"SUCCESS":                0,
	"FAILED_NOT_RETRYABLE":   1,
	"FAILED_RETRYABLE":       2,
	"SHARD_CONFIG_MISTMATCH": 3,
}

func (x ExportResponse_ResultCode) String() string {
	return proto.EnumName(ExportResponse_ResultCode_name, int32(x))
}
func (ExportResponse_ResultCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type ExportRequest struct {
	// Encoded record.
	Record *EncodedRecord `protobuf:"bytes,2,opt,name=record" json:"record,omitempty"`
	// The shard that the records were prepared for. The receiver will
	// accept the records if the current sharding configuration has a
	// shard with specified shardId and matching hash key range.
	Shard *ShardDefinition `protobuf:"bytes,3,opt,name=shard" json:"shard,omitempty"`
}

func (m *ExportRequest) Reset()                    { *m = ExportRequest{} }
func (m *ExportRequest) String() string            { return proto.CompactTextString(m) }
func (*ExportRequest) ProtoMessage()               {}
func (*ExportRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ExportRequest) GetRecord() *EncodedRecord {
	if m != nil {
		return m.Record
	}
	return nil
}

func (m *ExportRequest) GetShard() *ShardDefinition {
	if m != nil {
		return m.Shard
	}
	return nil
}

type EncodedRecord struct {
	// data is a byte sequence encoded as follows:
	// 1. github.com/signalfx/opencensus-go-exporter-kinesis/SpanList
	//    encoded in Protocol Buffer format.
	// 2. Result of step 1 compressed using gzip.
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	// Partition key defines the shard that this data is intended for.
	PartitionKey string `protobuf:"bytes,2,opt,name=partitionKey" json:"partitionKey,omitempty"`
	// Number of spans encoded in this record. Useful for recipient
	// to maintain span count stats without uncompressing the data.
	SpanCount int64 `protobuf:"varint,3,opt,name=spanCount" json:"spanCount,omitempty"`
	// Size of encoded but uncompressed data in bytes. Useful for recipient
	// to calculate compression ratio stats without uncompressing the data.
	UncompressedBytes int64 `protobuf:"varint,4,opt,name=uncompressedBytes" json:"uncompressedBytes,omitempty"`
}

func (m *EncodedRecord) Reset()                    { *m = EncodedRecord{} }
func (m *EncodedRecord) String() string            { return proto.CompactTextString(m) }
func (*EncodedRecord) ProtoMessage()               {}
func (*EncodedRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EncodedRecord) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *EncodedRecord) GetPartitionKey() string {
	if m != nil {
		return m.PartitionKey
	}
	return ""
}

func (m *EncodedRecord) GetSpanCount() int64 {
	if m != nil {
		return m.SpanCount
	}
	return 0
}

func (m *EncodedRecord) GetUncompressedBytes() int64 {
	if m != nil {
		return m.UncompressedBytes
	}
	return 0
}

type ExportResponse struct {
	// Result of request processing.
	ResultCode ExportResponse_ResultCode `protobuf:"varint,2,opt,name=resultCode,enum=omnishard.ExportResponse_ResultCode" json:"resultCode,omitempty"`
	// If resultCode=SHARD_CONFIG_MISTMATCH then this field
	// must contain the new sharding configuration otherwise
	// it should be omitted and ignored.
	ShardingConfig *ShardingConfig `protobuf:"bytes,3,opt,name=shardingConfig" json:"shardingConfig,omitempty"`
}

func (m *ExportResponse) Reset()                    { *m = ExportResponse{} }
func (m *ExportResponse) String() string            { return proto.CompactTextString(m) }
func (*ExportResponse) ProtoMessage()               {}
func (*ExportResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ExportResponse) GetResultCode() ExportResponse_ResultCode {
	if m != nil {
		return m.ResultCode
	}
	return ExportResponse_SUCCESS
}

func (m *ExportResponse) GetShardingConfig() *ShardingConfig {
	if m != nil {
		return m.ShardingConfig
	}
	return nil
}

type ShardDefinition struct {
	// The id of the shard.
	ShardId string `protobuf:"bytes,1,opt,name=shardId" json:"shardId,omitempty"`
	// Shard starting and ending hash keys.
	// hasKey is byte sequence representation of big.Int hash key.
	StartingHashKey []byte `protobuf:"bytes,2,opt,name=startingHashKey,proto3" json:"startingHashKey,omitempty"`
	EndingHashKey   []byte `protobuf:"bytes,3,opt,name=endingHashKey,proto3" json:"endingHashKey,omitempty"`
}

func (m *ShardDefinition) Reset()                    { *m = ShardDefinition{} }
func (m *ShardDefinition) String() string            { return proto.CompactTextString(m) }
func (*ShardDefinition) ProtoMessage()               {}
func (*ShardDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ShardDefinition) GetShardId() string {
	if m != nil {
		return m.ShardId
	}
	return ""
}

func (m *ShardDefinition) GetStartingHashKey() []byte {
	if m != nil {
		return m.StartingHashKey
	}
	return nil
}

func (m *ShardDefinition) GetEndingHashKey() []byte {
	if m != nil {
		return m.EndingHashKey
	}
	return nil
}

type ShardingConfig struct {
	// Sharding configuration is a list of shard definitions.
	ShardDefinitions []*ShardDefinition `protobuf:"bytes,1,rep,name=shardDefinitions" json:"shardDefinitions,omitempty"`
}

func (m *ShardingConfig) Reset()                    { *m = ShardingConfig{} }
func (m *ShardingConfig) String() string            { return proto.CompactTextString(m) }
func (*ShardingConfig) ProtoMessage()               {}
func (*ShardingConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ShardingConfig) GetShardDefinitions() []*ShardDefinition {
	if m != nil {
		return m.ShardDefinitions
	}
	return nil
}

type ConfigRequest struct {
}

func (m *ConfigRequest) Reset()                    { *m = ConfigRequest{} }
func (m *ConfigRequest) String() string            { return proto.CompactTextString(m) }
func (*ConfigRequest) ProtoMessage()               {}
func (*ConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func init() {
	proto.RegisterType((*ExportRequest)(nil), "omnishard.ExportRequest")
	proto.RegisterType((*EncodedRecord)(nil), "omnishard.EncodedRecord")
	proto.RegisterType((*ExportResponse)(nil), "omnishard.ExportResponse")
	proto.RegisterType((*ShardDefinition)(nil), "omnishard.ShardDefinition")
	proto.RegisterType((*ShardingConfig)(nil), "omnishard.ShardingConfig")
	proto.RegisterType((*ConfigRequest)(nil), "omnishard.ConfigRequest")
	proto.RegisterEnum("omnishard.ExportResponse_ResultCode", ExportResponse_ResultCode_name, ExportResponse_ResultCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for OmniShard service

type OmniShardClient interface {
	// Get the sharding configuration. Typically called at the beginning of
	// communication, before calling Export.
	GetShardingConfig(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*ShardingConfig, error)
	// Export a single request.
	Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*ExportResponse, error)
}

type omniShardClient struct {
	cc *grpc.ClientConn
}

func NewOmniShardClient(cc *grpc.ClientConn) OmniShardClient {
	return &omniShardClient{cc}
}

func (c *omniShardClient) GetShardingConfig(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*ShardingConfig, error) {
	out := new(ShardingConfig)
	err := grpc.Invoke(ctx, "/omnishard.OmniShard/GetShardingConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *omniShardClient) Export(ctx context.Context, in *ExportRequest, opts ...grpc.CallOption) (*ExportResponse, error) {
	out := new(ExportResponse)
	err := grpc.Invoke(ctx, "/omnishard.OmniShard/Export", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for OmniShard service

type OmniShardServer interface {
	// Get the sharding configuration. Typically called at the beginning of
	// communication, before calling Export.
	GetShardingConfig(context.Context, *ConfigRequest) (*ShardingConfig, error)
	// Export a single request.
	Export(context.Context, *ExportRequest) (*ExportResponse, error)
}

func RegisterOmniShardServer(s *grpc.Server, srv OmniShardServer) {
	s.RegisterService(&_OmniShard_serviceDesc, srv)
}

func _OmniShard_GetShardingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OmniShardServer).GetShardingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/omnishard.OmniShard/GetShardingConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OmniShardServer).GetShardingConfig(ctx, req.(*ConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OmniShard_Export_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OmniShardServer).Export(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/omnishard.OmniShard/Export",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OmniShardServer).Export(ctx, req.(*ExportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OmniShard_serviceDesc = grpc.ServiceDesc{
	ServiceName: "omnishard.OmniShard",
	HandlerType: (*OmniShardServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetShardingConfig",
			Handler:    _OmniShard_GetShardingConfig_Handler,
		},
		{
			MethodName: "Export",
			Handler:    _OmniShard_Export_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "omnishard.proto",
}

func init() { proto.RegisterFile("omnishard.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 472 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0xcd, 0x6a, 0xdb, 0x4c,
	0x14, 0xb5, 0xac, 0x7c, 0x0e, 0xba, 0xf1, 0x8f, 0x72, 0x09, 0x1f, 0xaa, 0xe9, 0xc2, 0x0c, 0x59,
	0x78, 0x51, 0x4c, 0x70, 0x1f, 0xa0, 0x28, 0xb2, 0x1c, 0xbb, 0x4d, 0x62, 0x18, 0xb9, 0xd0, 0xae,
	0x8c, 0xea, 0x99, 0x38, 0x82, 0x7a, 0x46, 0xd5, 0x8c, 0xa1, 0xa1, 0x9b, 0xbe, 0x43, 0x37, 0x7d,
	0xdc, 0x92, 0xf1, 0x9f, 0x46, 0xa1, 0x74, 0x23, 0x34, 0xe7, 0x9e, 0x73, 0xe7, 0x72, 0xee, 0x19,
	0xe8, 0xc8, 0xb5, 0xc8, 0xd4, 0x63, 0x5a, 0xb0, 0x41, 0x5e, 0x48, 0x2d, 0xd1, 0x3b, 0x00, 0x44,
	0x41, 0x2b, 0xfe, 0x9e, 0xcb, 0x42, 0x53, 0xfe, 0x6d, 0xc3, 0x95, 0xc6, 0x2b, 0x68, 0x14, 0x7c,
	0x29, 0x0b, 0x16, 0xd4, 0x7b, 0x4e, 0xff, 0x6c, 0x18, 0x0c, 0x8e, 0xea, 0x58, 0x2c, 0x25, 0xe3,
	0x8c, 0x9a, 0x3a, 0xdd, 0xf1, 0xf0, 0x0a, 0xfe, 0x33, 0xe5, 0xc0, 0x35, 0x82, 0x6e, 0x49, 0x90,
	0x3c, 0x7f, 0x47, 0xfc, 0x21, 0x13, 0x99, 0xce, 0xa4, 0xa0, 0x5b, 0x22, 0xf9, 0xe5, 0x40, 0xcb,
	0xea, 0x85, 0x08, 0x27, 0x2c, 0xd5, 0x69, 0xe0, 0xf4, 0x9c, 0x7e, 0x93, 0x9a, 0x7f, 0x24, 0xd0,
	0xcc, 0xd3, 0x42, 0x1b, 0xe5, 0x07, 0xfe, 0x64, 0xe6, 0xf1, 0xa8, 0x85, 0xe1, 0x6b, 0xf0, 0x54,
	0x9e, 0x8a, 0x48, 0x6e, 0x84, 0x36, 0xf7, 0xbb, 0xf4, 0x08, 0xe0, 0x1b, 0x38, 0xdf, 0x88, 0xa5,
	0x5c, 0xe7, 0x05, 0x57, 0x8a, 0xb3, 0xeb, 0x27, 0xcd, 0x55, 0x70, 0x62, 0x58, 0x2f, 0x0b, 0xe4,
	0x67, 0x1d, 0xda, 0x7b, 0x2f, 0x54, 0x2e, 0x85, 0xe2, 0x38, 0x02, 0x28, 0xb8, 0xda, 0x7c, 0xd5,
	0x91, 0x64, 0xdc, 0x0c, 0xd0, 0x1e, 0x5e, 0x96, 0x0d, 0xb1, 0xe8, 0x03, 0x7a, 0xe0, 0xd2, 0x92,
	0x0e, 0x43, 0x68, 0x1b, 0x7a, 0x26, 0x56, 0x91, 0x14, 0x0f, 0xd9, 0x6a, 0xe7, 0xd4, 0xab, 0xaa,
	0x53, 0x07, 0x02, 0xad, 0x08, 0x08, 0x07, 0x38, 0x36, 0xc7, 0x33, 0x38, 0x4d, 0x3e, 0x46, 0x51,
	0x9c, 0x24, 0x7e, 0x0d, 0x03, 0xb8, 0x18, 0x87, 0xd3, 0xdb, 0x78, 0xb4, 0xb8, 0x9f, 0xcd, 0x17,
	0x34, 0x9e, 0xd3, 0xcf, 0xe1, 0xf5, 0x6d, 0xec, 0x3b, 0x78, 0x01, 0xfe, 0xae, 0x72, 0x44, 0xeb,
	0xd8, 0x85, 0xff, 0x93, 0x49, 0x48, 0x47, 0x8b, 0x68, 0x76, 0x3f, 0x9e, 0xde, 0x2c, 0xee, 0xa6,
	0xc9, 0xfc, 0x2e, 0x9c, 0x47, 0x13, 0xdf, 0x25, 0x3f, 0xa0, 0x53, 0x59, 0x19, 0x06, 0x70, 0x6a,
	0x66, 0x99, 0x32, 0xb3, 0x1c, 0x8f, 0xee, 0x8f, 0xd8, 0x87, 0x8e, 0xd2, 0xcf, 0xcb, 0x10, 0xab,
	0x49, 0xaa, 0x1e, 0xf7, 0x2b, 0x6a, 0xd2, 0x2a, 0x8c, 0x97, 0xd0, 0xe2, 0x82, 0x95, 0x78, 0xae,
	0xe1, 0xd9, 0x20, 0xf9, 0x04, 0x6d, 0xdb, 0x05, 0x1c, 0x83, 0xaf, 0xec, 0x71, 0x54, 0xe0, 0xf4,
	0xdc, 0x7f, 0x84, 0xec, 0x85, 0x86, 0x74, 0xa0, 0xb5, 0xf3, 0x75, 0x1b, 0xf2, 0xe1, 0x6f, 0x07,
	0xbc, 0xd9, 0x5a, 0x64, 0x46, 0x8a, 0xef, 0xe1, 0xfc, 0x86, 0xeb, 0xca, 0xdd, 0xe5, 0xdc, 0x5b,
	0xe2, 0xee, 0xdf, 0xd7, 0x46, 0x6a, 0xf8, 0x0e, 0x1a, 0xdb, 0x50, 0x58, 0x0d, 0xac, 0x27, 0x66,
	0x35, 0xb0, 0x13, 0x44, 0x6a, 0x5f, 0x1a, 0xe6, 0x89, 0xbe, 0xfd, 0x13, 0x00, 0x00, 0xff, 0xff,
	0xd1, 0xf8, 0xbb, 0x0d, 0xb5, 0x03, 0x00, 0x00,
}
